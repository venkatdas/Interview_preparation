```js
// ============================================
// PROBLEM: Find Integer Square Root
// ============================================

import { log } from "console";

// ============================================
// CURRENT APPROACH: Linear/Brute Force
// ============================================
/**
 * EXPLANATION:
 * - Starts from 1 and increments i until i*i > num
 * - If i*i === num, it's a perfect square, return i
 * - If no perfect square found, return i-1 (floor of square root)
 * 
 * WHY IT'S NOT OPTIMIZED:
 * - Time Complexity: O(√n) - worst case loops √n times
 * - For sqrt(1000000), it loops ~1000 times
 * - This is too slow for large numbers
 * 
 * SPACE Complexity: O(1) - only uses constant space
 */
function sqrtLinear(num) {
  // Edge case: negative numbers don't have real square roots
  if (num < 0) {
    return NaN;
  }
  
  // Base cases: optimization for known values
  if (num === 0 || num === 1) {
    return num;
  }
  
  // Linear search: start from 1 and keep incrementing
  let i = 1;
  while (i * i <= num) {
    // Check if perfect square
    if (i * i === num) {
      return i;
    }
    i++; // Increment by 1 each time - INEFFICIENT!
  }
  
  // Return floor value for non-perfect squares
  return i - 1;
}

// ============================================
// OPTIMIZED APPROACH: Binary Search
// ============================================
/**
 * EXPLANATION:
 * - Uses binary search to find square root in O(log n) time
 * - Instead of checking every number 1,2,3... we divide search space in half
 * - Set left=1, right=num, check mid value
 * - If mid*mid < num, move left pointer up (go right in search space)
 * - If mid*mid > num, move right pointer down (go left in search space)
 * 
 * WHY IT'S OPTIMIZED:
 * - Time Complexity: O(log n) - much faster!
 * - For sqrt(1000000), only ~20 iterations instead of ~1000
 * - Reduces search space exponentially with each step
 * 
 * SPACE Complexity: O(1) - same constant space
 */
function sqrtOptimized(num) {
  // Edge case: negative numbers
  if (num < 0) {
    return NaN;
  }
  
  // Base cases: optimization
  if (num === 0 || num === 1) {
    return num;
  }
  
  // Binary search setup
  let left = 1;      // Start from 1
  let right = num;   // End at num (can optimize to num/2 for num > 1)
  
  // Binary search loop
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);  // Calculate middle point
    const square = mid * mid;
    
    if (square === num) {
      // Perfect square found
      return mid;
    } else if (square < num) {
      // mid is too small, search in right half
      left = mid + 1;
    } else {
      // mid is too big, search in left half
      right = mid - 1;
    }
  }
  
  // right will be the floor of square root
  return right;
}

// ============================================
// TEST CASES & COMPARISON
// ============================================
log("=== LINEAR APPROACH (NOT OPTIMIZED) ===");
log("sqrt(16) =", sqrtLinear(16));     // Output: 4
log("sqrt(17) =", sqrtLinear(17));     // Output: 4
log("sqrt(25) =", sqrtLinear(25));     // Output: 5
log("sqrt(2) =", sqrtLinear(2));       // Output: 1

log("\n=== OPTIMIZED APPROACH (BINARY SEARCH) ===");
log("sqrt(16) =", sqrtOptimized(16));  // Output: 4
log("sqrt(17) =", sqrtOptimized(17));  // Output: 4
log("sqrt(25) =", sqrtOptimized(25));  // Output: 5
log("sqrt(2) =", sqrtOptimized(2));    // Output: 1

// ============================================
// COMPLEXITY ANALYSIS
// ============================================
/**
 * LINEAR APPROACH:
 * - Time: O(√n) - iterates from 1 to √n
 * - Space: O(1) - constant extra space
 * - Example: sqrt(1,000,000) needs ~1000 iterations
 * 
 * BINARY SEARCH (OPTIMIZED):
 * - Time: O(log n) - halves search space each iteration
 * - Space: O(1) - constant extra space
 * - Example: sqrt(1,000,000) needs ~20 iterations
 * - IMPROVEMENT: 50x faster for large numbers!
 */
```
